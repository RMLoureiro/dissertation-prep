%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter3.tex
%% NOVA thesis document file
%%
%% Chapter with a short latex tutorial and examples
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter3.tex}%

\chapter{MOBs}
\label{cha:mobs}

\section{Overview}
\label{sub:overview}

MOBs standing for Modular Blockchain Simulator is divided into two main components,
the simulator a and the graphical user interface, we will look into them seperatly.

\subsection{Simulator}
\label{subsec:simulator}

The simulator makes use of OCaml's \textit{modules} and \textit{functors} to
provide modularity and extensibility. MOBs adopts a \textit{Discrete-Event Simulation Model}
making the state of the system only change in discrete points in time when events occur.
These events are stored in a queue ordered with two main values:
\begin{itemize}
  \item \textbf{Timestamp:} This value dictates the order in which the events are
stored in the queue and is based on the simulator's internal clock. When getting
a new event the simulator will fetch from the queue the one with the smallest timestamp
and move its internal clock to match that event's timestamp.
  \item \textbf{Target:} The entity that should process this event.
\end{itemize}
Events are fetched from the queue until no more events remain or a predefined
stopping condition is reached.

The simulator is built in a module based architecture, Figure (referencia) illustrates
how the different modules interact. These modules are:
\begin{itemize}
  \item \textbf{Main:} Entry point for the simulator, manages the execution of
protocols.
  \item \textbf{Protocol:} Top-level loop of the simulation, initializes the different
nodes, network topology, event queue and performs event handling and delegation.
  \item \textbf{Node:} This is a user defined module that describes the behaviour
of an entity in the simulated protocol.
  \item \textbf{Abstractions:} This module provides primitives to aid in the
development of new simulation such as proof of stake sortation, proof of work mining,
timers, alarms and message exchanges.
  \item \textbf{Statistics and Logging:}  Extract metrics and values from the execution
to be processed by the GUI.
\end{itemize}

\subsection{Graphical User Interface}
\label{subsec:grafical_user_interface}

The graphical user interface was implemented in NodeJs, Vue3 and ElectronJS.
The choice for web technologies enables the future deployement of simulator as
a web application. The GUI was developed with the goal of allowing the users
to use it with their own custom simulators as long as the following conditions are met:

\begin{enumerate}
  \item The simulator uses a parameters.json as an input with three categories,
General, Network and Protocol, the actual parameters inside each category are user defined.
  \item The output of the simulator produces log with two top-level entries, kind and content.
Kind can be one of ten values, each with their specific content, \textit{parameters, 
add-node, add-link, flow-message, add-block, node-committee, node-proposer, create-block,
statistics} and \textit{per-node-statistics}.
\end{enumerate}

The GUI is composed of 4 pages, described in the following sections.

\subsubsection{Parametrization}
\label{subsubsec:parametrization}

(referencia)

The Parameters window parses the parameters.json file and produces a form
where the user can customize the values or ranges of values for every parameter.

\subsubsection{Topology Specification}
\label{subsubsec:topology_specification}

The GUI also allows user to specify the topology of the network without needing
to manually write the JSON file. The Topology window offers a canvas to construct a network
topology as well as set individual parameters for each node.

(referencia imagens de topology window e parametrizations)

\subsubsection{Visualizer}
\label{subsubsec:visualizer}

(referencia imagiem de timelapse e informação dos nos)

The Visualizer window allows user to play the state of each node in a time-lapse manner
and visualize exchanged messages.

\subsubsection{Statistical Analysis}
\label{subsubsec:statistical_analysis}

The Statistics window aids in the analysis of the metrics produced by the simulator.
The GUI will parse the output.json file and display it in an easy to read format.
These formats can come as graphs, displaying minimum and maximum values observed
for each metric that was produced and a graph with per node statistics.

\section{Critical Analysis}
\label{sub:membership_protocols}

In (referencia tese) we can see a detailed state-of-the-art study on other simulator
tools for Blockchain protocols. In this study it is noted that each of the tools
studied is mostly built with a specific purpose and not in being modular or extensible
to allow for the study of new scenarios and protocols,
nor in wide parametrization for different testing scenarios. The table bellow shows an
overview of the functionalities that each existing simulator and MOBs offer.

\begin{table}[h]
  \tiny
  \centering
  \begin{tabular}{|c|c|c|c|c|c|c|c|}
    \hline
    & \textbf{\begin{tabular}[c]{@{}c@{}}Adversarial\\ Behavior\end{tabular}} & \textbf{\begin{tabular}[c]{@{}c@{}}Offline \\ Nodes\end{tabular}} & \textbf{\begin{tabular}[c]{@{}c@{}}Bandwidth\\  Limits\end{tabular}}                      & \textbf{\begin{tabular}[c]{@{}c@{}}Network \\ Topology\end{tabular}}   & \textbf{Proof of Stake}                                   & \textbf{Proof of Work}                                                   & \textbf{GUI} \\ \hline
    \textbf{VIBES}    & yes                                                                     & \begin{tabular}[c]{@{}c@{}}not \\ modeled\end{tabular}            & \begin{tabular}[c]{@{}c@{}}not\\ modeled\end{tabular}                                     & \begin{tabular}[c]{@{}c@{}}generated \\ via \\ parameters\end{tabular} & \begin{tabular}[c]{@{}c@{}}not \\ modeled\end{tabular}    & bitcoin                                                                  & yes          \\ \hline
    \textbf{BlockSim} & \begin{tabular}[c]{@{}c@{}}not\\ modeled\end{tabular}                   & \begin{tabular}[c]{@{}c@{}}not \\ modeled\end{tabular}            & \begin{tabular}[c]{@{}c@{}}Throughput \\ calculated \\ from \\ distributionn\end{tabular} & \begin{tabular}[c]{@{}c@{}}fully \\ linked\end{tabular}                & \begin{tabular}[c]{@{}c@{}}not \\ modeled\end{tabular}    & \begin{tabular}[c]{@{}c@{}}bitcoin \\ ethereum\end{tabular}              & no           \\ \hline
    \textbf{BlockSim} & \begin{tabular}[c]{@{}c@{}}not\\ modeled\end{tabular}                   & \begin{tabular}[c]{@{}c@{}}not \\ modeled\end{tabular}            & \begin{tabular}[c]{@{}c@{}}not \\ modeled\end{tabular}                                    & \begin{tabular}[c]{@{}c@{}}fully \\ linked\end{tabular}                & \begin{tabular}[c]{@{}c@{}}not \\ modeled\end{tabular}    & \begin{tabular}[c]{@{}c@{}}bitcoin \\ ethereum\end{tabular}              & no           \\ \hline
    \textbf{SimBlock} & \begin{tabular}[c]{@{}c@{}}not \\ modeled\end{tabular}                  & \begin{tabular}[c]{@{}c@{}}not \\ modeled\end{tabular}            & \begin{tabular}[c]{@{}c@{}}specify \\ expected \\ available \\ bandwidth\end{tabular}     & \begin{tabular}[c]{@{}c@{}}generated \\ via \\ params\end{tabular}     & \begin{tabular}[c]{@{}c@{}}simple \\ example\end{tabular} & \begin{tabular}[c]{@{}c@{}}bitcoin \\ dogecoin \\ litecoin\end{tabular}  & yes          \\ \hline
    \textbf{MOBs}     & yes                                                                     & yes                                                               & parameterizable                                                                           & \begin{tabular}[c]{@{}c@{}}generated \\ via \\ params\end{tabular}     & tenderbake                                                & \begin{tabular}[c]{@{}c@{}}bitcoin \\ algorand \\ ouroboros\end{tabular} & yes          \\ \hline
    \end{tabular}
  \caption{Feature comparison between existing blockchain simulators and MOBS.}
  \label{table:1}
\end{table}

VIBES (referencia), is scalable, fast and capable of simulating Bitcoin-like
protocols however, there is a lack of separation between the code that defines the
simulator and the codes that defines the protocols, which makes implementing new
protocols difficult and time costly. On the GUI provided this lack of separation
also exists, having the statistics that are displayed tied to the protocols being
simulated, which means that if the user wants to implement a new protocol that has
different metrics/statistics, changes would need to be done to the GUI to support
them.

Neither BlockSim, BlockSim nor SimBlock support adversarial or byzantine behavior
of the nodes, making it impossible to test the protocols when the network is not in
perfect conditions.

VIBEs, BlockSim and BlockSim do not model Proof of Stake protocols which hinders
their extensibility, since as a result, these simulators don't offer abstractions
for timers and alarms commonly used in proof of stake.

MOBs addresses these concerns like described above offering a more modular and extensible
environment, an independent GUI and the ability to simulate different families of protocols.

\section{Initial Exercise}
\label{sub:initial_exercise}
